const TelegramBot = require('node-telegram-bot-api');
const fs = require('fs');
const path = require('path');
const mongoose = require('mongoose');
const NodeCache = require( "node-cache" );
const {History, User, NodeObj, Decision, UserHistoryObj, Room, MyRoom} = require('./models');
const jsonfile = require('jsonfile');
const chalk = require('chalk');
const axios = require('axios');
const express = require('express');
const bodyParser = require('body-parser').json();
require('dotenv').config()
const { 
  debug, 
  debugSome, 
  findAndReturn,
  checkMessageRouter,
  prepareKeyboard,
  endPointHandler,
  prepareEndPointStr
} = require('./helpers');
const {
  profile_callback,
  profile_wakeup,
  show_mbti
} = require('./callback_handlers');
const { mainDev } = require('./dev');


const keyboards = require('./keyboards');
const kb = require('./keyboard_btns');

const log = console.log;
const cLog = pass => log(chalk.blue.bgRed.bold(pass));
const cacheBase = new NodeCache();

main().catch(err => console.log(err));

// ================================================================

async function main() {
  await mongoose.connect(process.env.DATABASE_URL);
  if(mongoose.connection) {
    console.log('Success connect')
  }
  
  // use `await mongoose.connect('mongodb://user:password@127.0.0.1:27017/test');` if your database has auth enabled
}

// ================================================================
const url = 'https://d88e-94-140-144-153.ngrok-free.app';
const port = 80;

// const bot = new TelegramBot(process.env.TELEGRAM_BOT_KEY, {
//   polling: {
//     interval: 300, // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø—Ä–∏—Ö–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–ª–∏–µ–Ω—Ç–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
//     autoStart: true, // –ë–æ—Ç –±—ã–ª –Ω–µ –∑–∞–ø—É—â–µ–Ω–æ –∏ –µ–º—É –±—ã–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ -> –æ–Ω –µ—ë –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç
//     params: {
//       timeout: 10 // –¢–∞–π–º–∞—É—Ç –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
//     }
//   }
// })

const bot = new TelegramBot(process.env.TELEGRAM_BOT_KEY, {
  baseApiUrl: "http://0.0.0.0:8081"
});
bot.setWebHook(`${url}/bot${process.env.TELEGRAM_BOT_KEY}`);
const app = express();
app.use(express.json());
// app.use(bodyParser, (req, res, next) => {
  
//   // console.log("REQ BODY", req);
//   next();
// });

app.post(`/bot${process.env.TELEGRAM_BOT_KEY}`, (req, res) => {
  console.time();
  // cLog("REQ BODY");
  // log(req.body);
  // console.log(req);
  bot.processUpdate(req.body);
  res.sendStatus(200);
});

app.listen(port, () => {
  cacheBase.set('live_set_location', {data: []});
  cacheBase.set('live_photo_send', {data: []});
  cacheBase.set('live_set_name', {data: []});
  console.log(`Express server is listening on ${port}`);
});

// bot.onText(/\/money/, message => {

//   bot.sendPhoto(message.chat.id, fs.readFileSync(__dirname+'/cute.jpg'), {
//     caption: "–ù–µ—Ç —Ç–∞–∫–æ–≥–æ... üéÉüëë‚ô†üí¢ ",  
//     parse_mode: 'Markdown'
//   });
//   // bot.sendPhoto(message.chat.id, './gumboll_emoji.jpg');
// })

bot.onText(/\/start/, async message => {
  const {id: chatId} = message.chat

  if(!message.from.hasOwnProperty('username')) {
    bot.sendMessage(chatId, "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ username –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Telegram");
    return;
  }

  const { from: {first_name, username, language_code} } = message;

  let user = await User.findOne({username});
  const msgData = await resMsg(user?.mbti);
  if(!user) {
    user = User({
      username,
      showName:first_name,
      first_name,
      chatId,
      language_code,
      mbti: '',
      inTest: false,

      visible: 'close',
      geoX: 0,
      geoY: 0,
      photo: '',
      showText: '',
      wish: "friend",
      rate: 100,
      resp: [],
      checked: [],
    });
  };
  user.msgId = msgData.message_id;
  // –≤—ã–±—Ä–æ—Å–∏—Ç—å. –ò–Ω—Ñ–∞ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏ –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –∫–∞–ª–±–µ–∫–µ

  user.save()
    .then(() => {
      log(chalk.blue.bgRed.bold('Success save'))
    })
    .catch(er => console.log("Mongo err: ", er));

  async function resMsg(showGroup = false) {
    console.log("showGroup ", showGroup); 
    const resMsgData = await bot.sendMessage(chatId, "–û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", {
      reply_markup: {
        inline_keyboard: [
          showGroup ?
          [
            {
              text: "–ü—Ä–æ—Ñ–∏–ª—å",
              callback_data: 'profile',
            },
            {
              text: "–ì—Ä—É–ø–ø—ã",
              callback_data: 'groups'
            },
            {
              
            }
          ]
          :
          [
            {
              text: "–ü—Ä–æ—Ñ–∏–ª—å",
              callback_data: 'profile',
            }
          ]
        ],
      },
      parse_mode: 'Markdown',
      disable_web_page_preview: true,
    });
    console.log("resMsgData ", resMsgData);
    return resMsgData;
  }
});

bot.onText(/\/dev/, async message => {
  const {id: chatId} = message.chat;
  if(message.from.username !== 'Den1Lay') {
    await bot.sendMessage(chatId, "–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫—É '–°—Ç–∞—Ä—Ç–æ–≤–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞'");
    return 
  }
  console.log('show')
  
});

bot.on('message', async (message) => {
  const {id: chatId } = message.chat;
  const username = message.from.username;
  log('message: ', message);
  
  const user = await User.findOne({username});
  const check_location_data = message?.location;

  const live_set_location = cacheBase.get('live_set_location');
  // –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –∏–∑–º–µ–Ω–µ–Ω–∏—è –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏
  if(check_location_data) {
    await bot.sendMessage(chatId, "–í–∞—à–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã", {
      reply_markup:{
        remove_keyboard: true
      }
    });
    log("check_location_data ", check_location_data);
    const { latitude, longitude } = check_location_data
    user.latitude = latitude;
    user.longitude = longitude;
    user.save().catch(er => log(er));
    profile_wakeup({user, bot, chatId});

    const usernameInd = live_set_location.data.indexOf(username);
    if(usernameInd != -1) {
      live_set_location.data.splice(usernameInd, 1);
      cacheBase.set('live_set_location', live_set_location);
    }
    return
  }

  // –ö–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞ –ª–∏—à–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –≤–Ω–∏–∑—É
  if(live_set_location.data.includes(username)) {
    const usernameInd = live_set_location.data.indexOf(username);
    if(usernameInd != -1) {
      live_set_location.data.splice(usernameInd, 1);
      cacheBase.set('live_set_location', live_set_location);
    }
    const msgData = await bot.sendMessage(chatId, "(‚åê‚ñ†_‚ñ†)", {
      reply_markup:{
        remove_keyboard: true
      }
    });
    bot.deleteMessage(chatId, msgData.message_id);
    return
  }
  
  // –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–æ—Ç–æ
  const check_photo_data = message?.photo;
  if(check_photo_data) {
    const live_photo_send = cacheBase.get('live_photo_send');

    if(live_photo_send.data.includes(username)) {
      
      bot.getFile(check_photo_data[check_photo_data.length-1].file_id).then((data) => {
        const usernameInd = live_photo_send.data.indexOf(username);
        live_photo_send.data.splice(usernameInd, 1);
        cacheBase.set('live_photo_send', live_photo_send);
        log('users_cache: ', live_photo_send);
        log("file data: ", data);
        const checkUserPhoto = user?.photo
        if(checkUserPhoto) {
          fs.unlink(checkUserPhoto, async er => {
            log(er);
            user.photo = data.file_path;
        
            user.save().catch(er => log(er));
            // –Ω—É–∂–Ω–æ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—É—é —Ñ–æ—Ç–∫—É, —á—Ç–æ–±—ã –Ω–µ —Å–∂–∏—Ä–∞—Ç—å –ø–∞–º—è—Ç—å
        
            profile_wakeup({user, bot, chatId, dlsMsg: '–í–∞—à–µ —Ñ–æ—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ\n'});
          });
        }
      })
      .catch(er => log(er));
    }
    return
  }

  const live_set_name = cacheBase.get('live_set_name');
  if(live_set_name.data.includes(username)) {
    const usernameInd = live_set_name.data.indexOf(username);
    live_set_name.data.splice(usernameInd, 1);
    cacheBase.set('live_set_name', live_set_name);

    user.showName = message.text;
    user.save().catch(er => log(er));

    profile_wakeup({user, bot, chatId, dlsMsg: '–í–∞—à–µ –∏–º—è –æ–±–Ω–æ–≤–ª–µ–Ω–æ\n'});
    return
  }
  
  // await bot.sendDocument(chatId, path.resolve(__dirname, 'Keil_v536.zip'));
  // console.log('message', message);
  console.timeEnd();

  return;
  // need to check another passes
  // –ï—â–µ –Ω—É–∂–Ω–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è, —á—Ç–æ–±—ã –æ–Ω–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞–ª–∏ –Ω–æ–º–µ—Ä–∞–º –∞ –∏–Ω–∞—á–µ —Å–∫–∏–ø
  // –ï—â–µ –Ω—É–∂–Ω–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –≥–∏—Ñ–∫–∏, –∫–∞—Ä—Ç–∏–Ω–∫–∏ –∏ –ø—Ä–æ—á–µ–µ, –ø—Ä–æ—á–µ–µ...

  // log(message, username);
  if(message.hasOwnProperty('location') && username === 'Den1Lay') {
    // log('backdoor');
    mainDev({userData, message, bot});
    return 
  };
  
  if(userData && userData.currentHistory !== 'null') {
    if(checkMessageRouter(message.text)) return;
    const chooseInd = message.text[0];
    // –≤–Ω–µ—Å–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ UserHistoryObj

    const workHis = findAndReturn(userData.histories, 'history_id', userData.currentHistory);

    const currentNodeObj = await NodeObj.findById(workHis.linkToNearNodeObj).populate(['decisions']);
    if(!currentNodeObj) return;

    const { nextNodeObj } = findAndReturn(currentNodeObj.decisions, 'index', chooseInd)
    
    
    await UserHistoryObj.updateOne({_id: workHis._id}, 
      {
        current_pos: workHis.current_pos+chooseInd,
        linkToNearNodeObj: nextNodeObj
      });
      
    // Get data for new keyboard
    const newNodeObj = await NodeObj.findById(nextNodeObj).populate(['decisions']);
    
    if(newNodeObj) {
      // show new keyboard
      // next step in test
      const keyboard = prepareKeyboard(newNodeObj.decisions);
      bot.sendMessage(chatId, newNodeObj.text, {
        reply_markup: {
          keyboard,
          resize_keyboard:true,
        }
      });
    } else {
      // end point
      // –ü–æ–∏—Å–∫ —Ñ—É–Ω–∫—Ü–∏–∏, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã, –∑–∞–ø–∏—Å—å –≤ –∫–æ–º–Ω–∞—Ç—É
      const {workRoom: preRoomData, newMyRoomObj} = await endPointHandler({bot, chatId, userData, pos: workHis.current_pos+chooseInd })
      // const roomData = await Room.findOne({unique_name}).populate(['members']);
      const roomData = await preRoomData.populate(['members']);
      const usersMyRooms = await MyRoom.find({room_id: roomData._id}).populate(['user_id']);

      const {str: resStr, noti} = prepareEndPointStr({roomData, userData, usersMyRooms});
      const { visible, notification } = newMyRoomObj;
      debugger
      const msgData = await bot.sendMessage(chatId, "(‚åê‚ñ†_‚ñ†)", {
        reply_markup: {
          remove_keyboard: true
        }
      })
      await bot.deleteMessage(msgData.chat.id, msgData.message_id);
      await bot.sendMessage(chatId, resStr, {
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: visible ? '–°–¥–µ–ª–∞—Ç—å –Ω–µ–≤–∏–¥–∏–º—ã–º' : '–°–¥–µ–ª–∞—Ç—å –≤–∏–¥–∏–º—ã–º',
                callback_data: 'endp'+'invs'+(visible ? 'off' : 'onn'),
              }
            ],
            [
              {
                text: notification ? '–û—Ç–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è' : '–í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è',
                callback_data: 'endp'+'noot'+(notification ? 'off' : 'onn'),
              }
            ],
          ]
        },
        parse_mode: 'Markdown',
        disable_web_page_preview: true,
      });

      await new Promise((resolve, reject) => {
        // —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        const sendNotification = (arr, i) => {
          if(i < arr.length) {
            bot.sendMessage(arr[i].chatId, "–ù–æ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤ –≥—Ä—É–ø–ø–µ (¬¨‚Äø¬¨)", {
              reply_markup: {
                inline_keyboard: [
                  [
                    {
                      text: "–°–º–æ—Ç—Ä–µ—Ç—å",
                      callback_data: 'endp'+'invs'+'onn'
                    }
                  ]
                ]
              }
            }).then(() => {
              sendNotification(arr, i+1);
            })
          } else {
            resolve()
          }
        }
        // resolve();
        sendNotification(noti, 0);
      })
      log('noti', noti);
    }
    

    
    // cLog('success index handler');


    return
  }
  

  // –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü
  switch(message.text) {
    case kb.back:
      bot.sendMessage(chatId, '–ù–∞—á–∞–ª—å–Ω–æ–µ –º–µ–Ω—é', {
        reply_markup: {
          keyboard: keyboards.origin,
          resize_keyboard:true,
        }
      })
      break
    case kb.origin.info:
      const str = `
      –û—Å–Ω–æ–≤–Ω–∞—è –∏–¥–µ—è –±–æ—Ç–∞ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ–±—ã –ø–æ–¥–æ–±—Ä–∞—Ç—å –¥–ª—è –í–∞—Å —á–µ–ª–æ–≤–µ–∫–∞ —Å –∫–æ—Ç–æ—Ä—ã–º –±—É–¥–µ—Ç –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ –æ–±—â–∞—Ç—å—Å—è.\n–î–ª—è —ç—Ç–æ–≥–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å —Ç–µ—Å—Ç –∏–∑ –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º—ã—Ö –∏ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã.\n–õ—é–¥–∏, –æ—Ç–≤–µ—Ç–∏–≤—à–∏–µ –Ω–∞ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã –æ–¥–∏–Ω–∞–∫–æ–≤–æ, –ø–æ–ø–∞–¥–∞—é—Ç –≤ –≥—Ä—É–ø–ø—ã, –≥–¥–µ –æ–Ω–∏ –ø–æ–ª—É—á–∞—é—Ç –¥–æ—Å—Ç—É–ø –∫ –ø—Ä–æ—Ñ–∏–ª—è–º –¥—Ä—É–≥ –¥—Ä—É–≥–∞.\n–í —Å–ª—É—á–∞–µ –µ—Å–ª–∏ –í—ã –≤–µ—Ä–Ω–µ—Ç–µ—Å—å –Ω–∞ –Ω–∞—á–∞–ª—å–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ –Ω–∞—á–Ω–µ—Ç–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —Ç–µ—Å—Ç, —Ç–æ –í—ã –±—É–¥–µ—Ç–µ —É–¥–∞–ª–µ–Ω—ã –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –∫–æ–º–Ω–∞—Ç—ã.\n–í—ã –º–æ–∂–µ—Ç–µ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ 2—Ö –∫–æ–º–Ω–∞—Ç–∞—Ö, –µ—Å–ª–∏ –æ–Ω–∏ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ —Ä–∞–∑–Ω—ã–º —Ç–µ—Å—Ç–∞–º. –î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø—Ä–∏—Å—Ç—É–ø–∏—Ç—å –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–∫—É "–ö —Ç–µ—Å—Ç–∞–º"`
      
      bot.sendMessage(chatId, str, {
        reply_markup: {
          keyboard: keyboards.origin,
          resize_keyboard:true,
        }
      })
      break
    case kb.origin.toTests:
      History.find().populate(['zero_node']).then(data => {
        data.forEach(history => {
          const { _id, name, comment, zero_node, unique_name } = history;
          const resText = `${name}\n${comment}`
          const sendMsg = () => {
            bot.sendMessage(chatId, resText, {
              reply_markup: {
                inline_keyboard: [
                  [
                    {
                      text: '–ü–µ—Ä–µ–π—Ç–∏',
                      callback_data: 'prev'+_id,
                    }
                  ],
                ]
              }
            });
          }
          if(unique_name !== 'dev') {
            sendMsg();
          }
          if(unique_name === 'dev' && message.from.username === 'Den1Lay') {
            sendMsg();
          }
          
        });
      })
        
      break
  }
  
})

bot.on('callback_query', async query => {
  const {id: chatId} = query.message.chat;
  const callback_data = query.data;
  // query.data = query.data.slice(4);
  console.log("query ", query);

  let user = await User.findOne({username: query.from.username});
  const username = query.from.username;
  // –Ω—É–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–µ—à–∞.

  if (callback_data === 'profile') {
    profile_callback({user, query, bot});
  }

  if(callback_data === 'set_geolocation') {
    const live_set_location = cacheBase.get('live_set_location');
    if(!live_set_location.data.includes(username)) {
      live_set_location.data.push(username);
      cacheBase.set('live_set_location', live_set_location);
    }
    bot.sendMessage(chatId, "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ", {
      reply_markup: {
        keyboard: [
          [
            {
              text: "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã", 
              request_location: true
            }
          ]
        ],
        resize_keyboard:true,
      }
    })
  }

  if(callback_data === 'set_photo') {
    const live_photo_send = cacheBase.get('live_photo_send');
    if(!live_photo_send.data.includes(username)) {
      live_photo_send.data.push(username);
      cacheBase.set('live_photo_send', live_photo_send);
    }
    bot.sendMessage(chatId, "–û—Ç–ø—Ä–∞–≤—å—Ç–µ 1 –∫–∞—Ä—Ç–∏–Ω–∫—É");

    console.log("live_photo_send: ", live_photo_send);
  }

  if(callback_data === 'set_show_name') {
    const live_set_name = cacheBase.get('live_set_name');
    if(!live_set_name.data.includes(username)) {
      live_set_name.data.push(username);
      cacheBase.set('live_set_name', live_set_name);
    }
    bot.sendMessage(chatId, '–ù–∞–ø–∏—à–∏—Ç–µ –Ω–æ–≤–æ–µ –∏–º—è');

    console.log("live_photo_send: ", live_set_name);
  }

  if(callback_data === 'set_visible') {
    const cv = user.visible;
    user.visible = cv === 'close' ? 'open' : cv === 'open' ? 'like' : 'close'
    user.save().catch(er => log(er));
    profile_callback({user, query, bot}, false);
  }

  if(callback_data === 'set_wish') {
    const sw = user.wish;
    user.wish = sw === 'friend' ? 'relation' : 'friend';
    user.save().catch(er => log(er));
    profile_callback({user, query, bot}, false);
  }
 
  if(callback_data === 'choose_mbti') {
    show_mbti({user, query, bot});
  }

  if(callback_data.slice(0, 8) === 'set_mbti') {
    const payload_type = callback_data.slice(9);
    user.mbti = payload_type;
    user.save().catch(er => log(er));
    profile_callback({user, query, bot});
  }

  if(callback_data === 'return_profile') {
    profile_callback({user, query, bot});
  }
  
})